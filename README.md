# FastBean
A fast, bytecode powered bean mapping library.

FastBean allows you to create instances, fill and extract POJO properties. It's blazing fast by generating bytecode on the fly.

## Usage
You may have a POJO class similar to the one below:
```java
class User {
    public String name;
    private int age;

    public void setAge(int age) {
        this.age = age;
    }
    
    public int getAge() {
        return age;
    }
}
```

You can compile that class into a Bean mapper class:
```java
Bean<User> bean = FastBean.compile(User.class);
```

The generated `Bean` instance allows you to create a new instance and fill and extract the properties without using reflection or method handles.

Here's an example showing how you can create a new instance, fill with data from a map:
```java
HashMap<String, Object> data = new HashMap<>();
data.put("name", "John");
data.put("age", 20);

User user = bean.create();
bean.fill(user, data::get);

// data.name and data.getAge() will now return John and 20 respectively
```

You can also extract data:
```java
HashMap<String, Object> map = new HashMap<>();

user.name = "Mark";

bean.extract(user, map::put);

// map.get("name") will return "Mark"
// map.get("age") will return 20
```

Easy, right?

## What does it do behind the curtains?
Here's the class generated by FastBean when you compile:
```java
class UserBean implements Bean<User> {
    
    @Override
    public User create() {
        return new User();
    }

    @Override
    public void fill(User instance, IPropertyGetter converter) {
        instance.setAge(converter.getInt("age"));
        instance.name = converter.getString("name");
    }
    
    @Override
    public void extract(User instance, IPropertySetter converter) {
        converter.setInt("age", instance.getAge());
        converter.setString("name", instance.name);
    }

}
```
The class is actually generated directly into Java bytecode, not Java code. This is only a representation of what it actually does.

FastBean is fast just because of that: it doesn't rely on reflection to manipulate the POJO class, it generates a class that handles those operations directly.
